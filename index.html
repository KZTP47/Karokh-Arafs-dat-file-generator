<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karokh's DAT-filgenerator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #10c780 0%, #000000 100%);
            min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px;
        }
        .container {
            background: rgba(255, 255, 255, 0.98); backdrop-filter: blur(10px);
            border-radius: 20px; padding: 40px; max-width: 900px; width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        h1, h2 { color: #333; text-align: center; margin-bottom: 10px; }
        h2 { margin-top: 30px; }
        .section { margin-bottom: 30px; }
        .rules-section p { text-align: center; color: #666; margin-bottom: 15px; max-width: 600px; margin-left: auto; margin-right: auto; }
        .file-input-group { display: flex; gap: 20px; justify-content: center; margin-bottom: 20px; }
        .file-input {
            background: #f0f0f0; border-radius: 10px; padding: 20px; flex: 1; text-align: center;
            border: 2px dashed #ccc; transition: background 0.3s, border-color 0.3s;
        }
        .file-input:hover { background: #e9e9e9; border-color: #764ba2; }
        .file-input label { font-weight: bold; color: #555; display: block; margin-bottom: 10px; }
        .file-input input[type="file"] { width: 100%; }
        .rule { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; background: #f9f9f9; padding: 10px; border-radius: 8px; }
        .rule input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 5px; flex-grow: 1; }
        .rule span { white-space: nowrap; }
        button {
            background-color: #667eea; color: white; padding: 12px 25px; border: none; border-radius: 8px;
            cursor: pointer; font-size: 16px; font-weight: bold; transition: background-color 0.3s, transform 0.2s;
            display: block; margin: 15px auto 0 auto;
        }
        button:hover { background-color: #5a6fd8; transform: translateY(-2px); }
        #downloadBtn { background-color: #28a745; }
        #downloadBtn:hover { background-color: #218838; }
        .action-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 15px; }
        .status { padding: 15px; border-radius: 8px; margin-top: 20px; text-align: center; font-weight: bold; }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.info { background-color: #cce5ff; color: #004085; }
        #outputPreview { width: 100%; height: 200px; border-radius: 8px; border: 1px solid #ccc; padding: 10px; font-family: 'Courier New', Courier, monospace; font-size: 14px; }
        .remove-rule-btn {
            background: #dc3545; color: white; border: none; border-radius: 50%; width: 25px; height: 25px;
            cursor: pointer; font-weight: bold; padding: 0; line-height: 25px; text-align: center; flex-shrink: 0;
        }
        .remove-rule-btn:hover { background: #c82333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Karokh's DAT-filgenerator</h1>

        <div class="section">
            <h2>1. Ladda upp filer</h2>
            <div class="file-input-group">
                <div class="file-input">
                    <label for="inputFile">CSV- eller XLSX-fil</label>
                    <input type="file" id="inputFile" accept=".csv,.xlsx">
                </div>
                <div class="file-input">
                    <label for="xmlFile">XML-fil</label>
                    <input type="file" id="xmlFile" accept=".xml">
                </div>
            </div>
        </div>
        <!-- Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf -->
        <div class="section rules-section">
            <h2>2. Definiera IG-regler (frivilligt)</h2>
            <p>Dessa regler bestämmer IG-värdet. Om ingen regel matchar används "IG1" som standard.</p>
            <div id="igRulesContainer"></div>
            <button id="addIgRuleBtn">Lägg till IG-regel</button>
        </div>

        <div class="section rules-section">
            <h2>3. Sökmappningsregler (viktigt)</h2>
            <p>Dessa regler styr sökningen i XML-filen. Ange ett eller flera XML-suffix (kommaseparerade) för varje ID-prefix från indatafilen.</p>
            <div id="mappingRulesContainer"></div>
            <button id="addMappingBtn">Lägg till Sökregel</button>
        </div>

        <div class="section">
            <h2>4. Generera fil</h2>
            <div id="status" class="status" style="display:none;"></div>
            <div class="action-buttons">
                <button id="generateBtn">Generera DAT-fil</button>
                <button id="downloadBtn" style="display:none;">Ladda ner DAT-fil</button>
            </div>
        </div>

        <div class="section">
            <h2>Förhandsgranskning</h2>
            <textarea id="outputPreview" readonly placeholder="Genererat innehåll visas här..."></textarea>
        </div>
    </div>
<!-- Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf, Karokh Araf -->
    <script>
        let generatedContent = '';
        let csvData = null;
        let xmlDoc = null;

        document.getElementById('inputFile').addEventListener('change', handleInputFile);
        document.getElementById('xmlFile').addEventListener('change', handleXMLFile);
        document.getElementById('addMappingBtn').addEventListener('click', addMappingRule);
        document.getElementById('addIgRuleBtn').addEventListener('click', addIgRule);
        document.getElementById('generateBtn').addEventListener('click', generateDAT);
        document.getElementById('downloadBtn').addEventListener('click', downloadDATFile);
        
        // UPPDATERAD: Denna funktion hanterar nu både CSV och XLSX
        function handleInputFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            const fileName = file.name.toLowerCase();

            if (fileName.endsWith('.xlsx')) {
                // Logik för att hantera XLSX-filer
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    csvData = XLSX.utils.sheet_to_csv(worksheet, { header: 1 });
                    showStatus(`XLSX-fil '${file.name}' har lästs in och konverterats.`, 'info');
                };
                reader.readAsArrayBuffer(file);
            } else {
                // Befintlig logik för CSV-filer
                reader.onload = (e) => {
                    csvData = e.target.result;
                    showStatus(`CSV-fil '${file.name}' har lästs in.`, 'info');
                };
                reader.readAsText(file, 'ISO-8859-1');
            }
            reader.onerror = () => showStatus(`Fel vid inläsning av fil: ${file.name}`, 'error');
        }

        function handleXMLFile(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(e.target.result, "application/xml");
                    if (xmlDoc.getElementsByTagName("parsererror").length > 0) throw new Error("XML-filen är ogiltig.");
                    showStatus(`XML-fil '${file.name}' har lästs in.`, 'info');
                } catch (error) {
                    showStatus('Fel vid tolkning av XML-fil: ' + error.message, 'error'); xmlDoc = null;
                }
            };
            reader.onerror = () => showStatus(`Fel vid inläsning av fil: ${file.name}`, 'error');
            reader.readAsText(file, 'ISO-8859-1');
        }
        
        function addMappingRule() {
            const container = document.getElementById('mappingRulesContainer');
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'rule';
            ruleDiv.innerHTML = `
                <span>Om ID börjar med:</span>
                <input type="text" class="rule-prefix" placeholder="t.ex. SI">
                <span>sök efter XML-suffix:</span>
                <input type="text" class="rule-value" placeholder="t.ex. dsi, hsi">
                <button class="remove-rule-btn" title="Ta bort regel">X</button>
            `;
            container.appendChild(ruleDiv);
            ruleDiv.querySelector('.remove-rule-btn').addEventListener('click', () => container.removeChild(ruleDiv));
        }

        function addIgRule() {
            const container = document.getElementById('igRulesContainer');
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'rule';
            ruleDiv.innerHTML = `
                <span>Om ID börjar med:</span>
                <input type="text" class="rule-prefix" placeholder="t.ex. VX">
                <span>använd IG:</span>
                <input type="text" class="rule-value" placeholder="t.ex. IG11">
                <button class="remove-rule-btn" title="Ta bort regel">X</button>
            `;
            container.appendChild(ruleDiv);
            ruleDiv.querySelector('.remove-rule-btn').addEventListener('click', () => container.removeChild(ruleDiv));
        }

        function getRules(containerId) {
             const rules = [];
             document.querySelectorAll(`#${containerId} .rule`).forEach(ruleDiv => {
                const prefix = ruleDiv.querySelector('.rule-prefix').value.trim().toUpperCase();
                const value = ruleDiv.querySelector('.rule-value').value.trim();
                if (prefix && value) rules.push({ prefix, value });
            });
            return rules;
        }

        async function generateDAT() {
            try {
                if (!csvData) throw new Error("Vänligen ladda upp en CSV- eller XLSX-fil.");
                if (!xmlDoc) throw new Error("Vänligen ladda upp en XML-fil.");

                const mappingRules = getRules('mappingRulesContainer');
                const igRules = getRules('igRulesContainer');
                
                const rows = csvData.trim().split(/\r?\n/);
                if (rows.length === 0) throw new Error("Indatafilen är tom eller felaktigt formaterad.");

                const firstLine = rows[0];
                const commaCount = (firstLine.match(/,/g) || []).length;
                const semicolonCount = (firstLine.match(/;/g) || []).length;
                const delimiter = semicolonCount > commaCount ? ';' : ',';

                const outputLines = [];
                const indications = Array.from(xmlDoc.getElementsByTagName('Indication700'));
                
                // Börja från rad 1 (index 1) för att hoppa över eventuell rubrikrad
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row) continue;
                    
                    const cols = row.split(delimiter); 
                    if (cols.length < 10) continue; 

                    const recordType = '1';
                    const ebilockNo = cols[9].trim(); 
                    const id = cols[6].trim().replace(/\s/g, '').toUpperCase();
                    
                    const normalizedH = cols[7].trim().replace(/\s+/g, ' ');
                    const terminal = normalizedH.substring(0, 3);
                    const baseSearchTerm = (normalizedH.split(' ')[0] + ' ' + normalizedH.split(' ')[1]).trim();

                    if (!id || !ebilockNo || !baseSearchTerm || !cols[6] || !cols[7] || !cols[9]) continue;

                    let ig = 'IG1';
                    const matchingIgRule = igRules.find(rule => id.startsWith(rule.prefix));
                    if (matchingIgRule) ig = matchingIgRule.value;

                    const matchingMapRule = mappingRules.find(rule => id.startsWith(rule.prefix));
                    
                    let candidates = [];
                    if (matchingMapRule) {
                        const requiredSuffixes = matchingMapRule.value.split(',').map(s => s.trim()).filter(s => s);
                        for (const suffix of requiredSuffixes) {
                            const preciseSearchTerm = `${baseSearchTerm} ${suffix}`;
                            const found = indications.filter(ind => {
                                const objectElement = ind.querySelector('Object');
                                if (!objectElement) return false;
                                const objectText = objectElement.textContent.trim().replace(/\s+/g, ' ');
                                return objectText === preciseSearchTerm;
                            });
                            candidates.push(...found);
                        }
                    } else {
                        candidates = indications.filter(ind => {
                            const objectElement = ind.querySelector('Object');
                            if (!objectElement) return false;
                            const objectText = objectElement.textContent.trim().replace(/\s+/g, ' ');
                            return objectText.startsWith(baseSearchTerm);
                        });
                    }

                    if (candidates.length === 0) {
                        console.warn(`Ingen matchning hittades i XML för: "${baseSearchTerm}" (ID: ${id})`);
                        continue;
                    }

                    let bestCandidate = null;
                    let lowestBitValue = Infinity;
                    for (const candidate of candidates) {
                        const bitElement = candidate.querySelector('Bit');
                        if (bitElement) {
                            const bitHex = bitElement.textContent.trim();
                            const bitDecimal = parseInt(bitHex, 16);
                            if (!isNaN(bitDecimal) && bitDecimal < lowestBitValue) {
                                lowestBitValue = bitDecimal;
                                bestCandidate = candidate;
                            }
                        }
                    }
                    
                    if (!bestCandidate) continue;

                    const word = bestCandidate.querySelector('Wd').textContent.trim();
                    const bitHex = bestCandidate.querySelector('Bit').textContent.trim();
                    const bit = convertBitToDecimal(bitHex);
                    outputLines.push([recordType, ebilockNo, id, ig, terminal, word, bit].join(';'));
                }

                if (outputLines.length === 0) {
                     throw new Error("Inga rader kunde genereras. Kontrollera att indatafilerna har innehåll på förväntat format och att reglerna är korrekta.");
                }

                generatedContent = outputLines.join('\r\n');
                document.getElementById('outputPreview').value = generatedContent;
                document.getElementById('downloadBtn').style.display = 'inline-block';
                showStatus(`DAT-filen har genererats framgångsrikt! (${outputLines.length} rader)`, 'success');

            } catch (error) {
                showStatus('Fel vid generering av DAT-fil: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        function convertBitToDecimal(bit) {
            const hexMap = { 'F': '15', 'E': '14', 'D': '13', 'C': '12', 'B': '11', 'A': '10', '9': '9', '8': '8', '7': '7', '6': '6', '5': '5', '4': '4', '3': '3', '2': '2', '1': '1', '0': '0' };
            return hexMap[bit.toUpperCase()] || '0';
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
        }
        
        function downloadDATFile() {
            if (!generatedContent) {
                showStatus('Inget innehåll att ladda ner.', 'error');
                return;
            }
            const blob = new Blob([generatedContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.dat';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>

